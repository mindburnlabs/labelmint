#include "imports/stdlib.fc";

;; Enhanced operation codes with security events
const int op::transfer = 0x5fcc3d14; ;; Internal transfer
const int op::deposit = 0x4e4f5445; ;; Direct TON deposit
const int op::withdraw = 0x5749544844; ;; Withdraw request
const int op::create_channel = 0x4348414e4e454c; ;; Create payment channel
const int op::close_channel = 0x434c4f5345; ;; Close payment channel
const int op::channel_payment = 0x4348414e4e454c504159; ;; Channel payment
const int op::get_state = 0x47455453; ;; External state query

;; USDT Jetton operations
const int op::jetton_transfer_notification = 0x7362d09c; ;; Jetton transfer notification
const int op::jetton_internal_transfer = 0x178d4519; ;; Internal jetton transfer

;; Security operations with enhanced controls
const int op::emergency_pause = 0x5041555345; ;; Emergency pause
const int op::emergency_withdraw = 0x45574d4752; ;; Emergency withdraw
const int op::change_owner = 0x4f574e4552; ;; Change owner
const int op::propose_owner_change = 0x50524f504f5345; ;; Propose owner change
const int op::confirm_owner_change = 0x434f4e4649524d; ;; Confirm owner change
const int op::set_time_lock = 0x54494d454c4f434b; ;; Set time lock
const int op::upgrade_contract = 0x55504752414445; ;; Upgrade contract

;; Security event operations
const int op::security_event = 0x53454355524954; ;; Security event logging
const int op::access_control = 0x414343455353; ;; Access control event

;; Enhanced error codes with security-specific errors
const int err::unauthorized = 401;
const int err::invalid_operation = 400;
const int err::insufficient_funds = 410;
const int err::contract_paused = 423;
const int err::channel_not_found = 404;
const int err::channel_expired = 410;
const int err::invalid_amount = 400;
const int err::reentrancy_detected = 500;
const int err::overflow_detected = 501;
const int err::underflow_detected = 502;
const int err::time_lock_active = 503;
const int err::invalid_signature = 504;
const int err::contract_upgraded = 505;
const int err::operation_not_allowed = 506;
const int err::gas_limit_exceeded = 507;
const int err::invalid_timestamp = 508;

;; Security constants
const int max_gas_limit = 1000000; ;; Maximum gas for external calls
const int time_lock_delay = 48 * 60 * 60; ;; 48 hours in seconds
const int max_single_operation = 1000000 * 1000000000; ;; 1M TON max per operation
const int emergency_cooldown = 24 * 60 * 60; ;; 24 hours emergency cooldown

;; Role-based access control constants
const int role::owner = 0;
const int role::admin = 1;
const int role::operator = 2;
const int role::auditor = 3;

;; Enhanced secure storage with comprehensive security features
;; storage#_ owner:MsgAddressInt paused:Bool balance:Coins usdt_balance:Coins
;;         channel_count:uint32 emergency_withdraw_enabled:Bool reentrancy_guard:Bool
;;         time_lock:Uint32 proposed_owner:MsgAddressInt owner_change_time:Uint32
;;         access_control:Hash security_events:uint256 = Storage;
(slice, (int, int, int, int, int, int, int, int, int, int, int)) load_data() inline {
    slice ds = get_data().begin_parse();
    return (
        ds,
        (ds~load_msg_addr(), ;; owner
         ds~load_uint(1), ;; paused flag
         ds~load_coins(), ;; total TON balance in nanoTON
         ds~load_coins(), ;; total USDT balance (with 6 decimals)
         ds~load_uint(32), ;; channel count
         ds~load_uint(1), ;; emergency withdraw enabled
         ds~load_uint(1), ;; reentrancy guard
         ds~load_uint(32), ;; time lock
         ds~load_msg_addr(), ;; proposed owner
         ds~load_uint(32), ;; owner change time
         ds~load_uint(256), ;; access control hash
         ds~load_uint(256)) ;; security events counter
    );
}

;; Save enhanced secure storage
() save_data(int owner, int paused, int ton_balance, int usdt_balance, int channel_count,
             int emergency_enabled, int reentrancy_guard, int time_lock, int proposed_owner,
             int owner_change_time, int access_control_hash, int security_events) impure inline {
    set_data(begin_cell()
        .store_slice(parse_std_addr(owner))
        .store_uint(paused, 1)
        .store_coins(ton_balance)
        .store_coins(usdt_balance)
        .store_uint(channel_count, 32)
        .store_uint(emergency_enabled, 1)
        .store_uint(reentrancy_guard, 1)
        .store_uint(time_lock, 32)
        .store_slice(parse_std_addr(proposed_owner))
        .store_uint(owner_change_time, 32)
        .store_uint(access_control_hash, 256)
        .store_uint(security_events, 256)
        .end_cell());
}

;; Reentrancy protection
() set_reentrancy_guard(int enabled) impure inline {
    (_, (int owner, int paused, int ton_balance, int usdt_balance, int channel_count,
         int emergency_enabled, _, int time_lock, int proposed_owner,
         int owner_change_time, int access_control_hash, int security_events)) = load_data();
    save_data(owner, paused, ton_balance, usdt_balance, channel_count,
              emergency_enabled, enabled, time_lock, proposed_owner,
              owner_change_time, access_control_hash, security_events);
}

;; Check reentrancy guard
() check_reentrancy() impure inline {
    (_, (int owner, int paused, int ton_balance, int usdt_balance, int channel_count,
         int emergency_enabled, int reentrancy_guard, int time_lock, int proposed_owner,
         int owner_change_time, int access_control_hash, int security_events)) = load_data();
    throw_if(err::reentrancy_detected, reentrancy_guard);
}

;; Safe arithmetic operations with overflow/underflow protection
(int) safe_add(int a, int b) inline {
    throw_if(err::overflow_detected, (a + b) < a);
    return a + b;
}

(int) safe_sub(int a, int b) inline {
    throw_if(err::underflow_detected, a < b);
    return a - b;
}

(int) safe_mul(int a, int b) inline {
    throw_if(err::overflow_detected, b != 0 & (a * b) / b != a);
    return a * b;
}

;; Enhanced access control with role-based permissions
(int) check_access(slice sender_address, int required_role) impure inline {
    (_, (int owner, int paused, int ton_balance, int usdt_balance, int channel_count,
         int emergency_enabled, int reentrancy_guard, int time_lock, int proposed_owner,
         int owner_change_time, int access_control_hash, int security_events)) = load_data();

    ;; Check if sender is owner (highest privilege)
    if (equal_slices(parse_std_addr(sender_address), parse_std_addr(owner))) {
        return role::owner;
    }

    ;; TODO: Implement role-based access control with proper user roles
    ;; For now, only owner has access
    throw(err::unauthorized);
}

;; Time lock for sensitive operations
() check_time_lock(int operation_time) impure inline {
    (_, (int owner, int paused, int ton_balance, int usdt_balance, int channel_count,
         int emergency_enabled, int reentrancy_guard, int time_lock, int proposed_owner,
         int owner_change_time, int access_control_hash, int security_events)) = load_data();

    throw_if(err::time_lock_active, operation_time < time_lock);
}

;; Security event logging
() log_security_event(int event_type, slice actor, int amount, int timestamp) impure inline {
    (_, (int owner, int paused, int ton_balance, int usdt_balance, int channel_count,
         int emergency_enabled, int reentrancy_guard, int time_lock, int proposed_owner,
         int owner_change_time, int access_control_hash, int security_events)) = load_data();

    ;; Increment security events counter
    int new_security_events = safe_add(security_events, 1);

    ;; Save updated security events counter
    save_data(owner, paused, ton_balance, usdt_balance, channel_count,
              emergency_enabled, reentrancy_guard, time_lock, proposed_owner,
              owner_change_time, access_control_hash, new_security_events);

    ;; TODO: Emit security event (implement proper event emission)
    ;; For now, just increment counter
}

;; Gas limit validation
() validate_gas_limit(int gas_amount) impure inline {
    throw_if(err::gas_limit_exceeded, gas_amount > max_gas_limit);
}

;; Timestamp validation
() validate_timestamp(int timestamp) impure inline {
    int current_time = now();
    throw_if(err::invalid_timestamp, timestamp > current_time + 300); ;; Allow 5 minutes future
    throw_if(err::invalid_timestamp, timestamp < current_time - 86400); ;; Reject > 24 hours past
}

;; Operation amount validation
() validate_operation_amount(int amount) impure inline {
    throw_if(err::invalid_amount, amount <= 0);
    throw_if(err::invalid_amount, amount > max_single_operation);
}

;; Enhanced message validation
() validate_message_structure(slice msg_body, int expected_min_size) impure inline {
    throw_if(err::invalid_operation, msg_body.slice_bits() < expected_min_size);
}

;; Get contract owner (secure method)
(int) get_owner() method_id {
    (_, (int owner, _, _, _, _, _, _, _, _, _, _, _)) = load_data();
    return owner;
}

;; Get TON balance
(int) get_ton_balance() method_id {
    (_, (_, _, int ton_balance, _, _, _, _, _, _, _, _, _)) = load_data();
    return ton_balance;
}

;; Get USDT balance
(int) get_usdt_balance() method_id {
    (_, (_, _, _, int usdt_balance, _, _, _, _, _, _, _, _)) = load_data();
    return usdt_balance;
}

;; Get total balance (backward compatibility)
(int) get_balance() method_id {
    (_, (_, _, int ton_balance, _, _, _, _, _, _, _, _, _)) = load_data();
    return ton_balance;
}

;; Get channel count
(int) get_channel_count() method_id {
    (_, (_, _, _, _, int channel_count, _, _, _, _, _, _, _)) = load_data();
    return channel_count;
}

;; Get contract status (enhanced with security info)
(int, int, int, int, int) get_contract_status() method_id {
    (_, (int owner, int paused, int ton_balance, int usdt_balance, int channel_count,
         int emergency_enabled, int reentrancy_guard, int time_lock, int proposed_owner,
         int owner_change_time, int access_control_hash, int security_events)) = load_data();
    return (paused, emergency_enabled, channel_count, reentrancy_guard, security_events);
}

;; Enhanced receive message with comprehensive security
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    ;; Basic message validation
    if (in_msg_body.slice_empty?()) {
        return ();
    }

    ;; Validate message structure
    validate_message_structure(in_msg_body, 32);

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);

    if (flags & 1) { ;; ignore bounced messages
        return ();
    }

    slice sender_address = cs~load_msg_addr();
    (_, (int owner, int paused, int ton_balance, int usdt_balance, int channel_count,
         int emergency_enabled, int reentrancy_guard, int time_lock, int proposed_owner,
         int owner_change_time, int access_control_hash, int security_events)) = load_data();

    ;; Extract operation code safely
    int op = in_msg_body~load_uint(32);

    ;; Enhanced pause check with circuit breaker
    if (paused & (op != op::emergency_withdraw) & (op != op::change_owner) & (op != op::confirm_owner_change)) {
        throw(err::contract_paused);
    }

    ;; Reentrancy protection for all operations except view operations
    if ((op != op::get_state) & (op != op::security_event)) {
        check_reentrancy();
        set_reentrancy_guard(true);
    }

    ;; Handle USDT Jetton transfer notifications with enhanced security
    if (op == op::jetton_transfer_notification) {
        ;; Validate message structure
        validate_message_structure(in_msg_body, 64 + 256 + 256 + 256 + 256 + 1);

        ;; USDT Jetton transfer received with enhanced validation
        in_msg_body~load_uint(64); ;; query_id
        int jetton_amount = in_msg_body~load_coins(); ;; USDT amount
        slice from_address = in_msg_body~load_msg_addr(); ;; sender

        ;; Validate operation amount
        validate_operation_amount(jetton_amount);

        in_msg_body~load_msg_addr(); ;; response_destination (ignore)
        in_msg_body~load_coins(); ;; forward_ton_amount (ignore)

        ;; Extract payload if present with validation
        cell? payload_ref = in_msg_body~load_maybe_ref();
        int deposit_amount = 0;
        slice recipient = from_address; ;; Default to sender

        if (payload_ref.not_null()) {
            slice payload = payload_ref.begin_parse();
            if (payload.slice_bits() >= 32) {
                if (payload~load_uint(32) == op::deposit) {
                    deposit_amount = payload~load_coins();
                    recipient = payload~load_msg_addr();
                    validate_operation_amount(deposit_amount);
                }
            }
        }

        ;; Safe balance update with overflow protection
        usdt_balance = safe_add(usdt_balance, jetton_amount);
        save_data(owner, paused, ton_balance, usdt_balance, channel_count,
                  emergency_enabled, reentrancy_guard, time_lock, proposed_owner,
                  owner_change_time, access_control_hash, security_events);

        ;; Log security event
        log_security_event(op::security_event, from_address, jetton_amount, now());

        ;; Send confirmation with gas limit validation
        validate_gas_limit(50000); ;; Limit gas for external call
        var msg = begin_cell()
            .store_uint(0x10, 6) ;; bounce bit
            .store_slice(recipient)
            .store_coins(0)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_uint(0x55534454524543, 32) ;; USDTRECEIVED
            .store_coins(jetton_amount)
            .end_cell();

        send_raw_message(msg, 64);

    } elseif (op == op::deposit) {
        ;; Enhanced access control for deposits
        int user_role = check_access(sender_address, role::owner);
        throw_unless(err::unauthorized, user_role == role::owner);

        ;; Validate message structure
        validate_message_structure(in_msg_body, 64 + 256);

        ;; Direct TON deposit with enhanced validation
        int amount = in_msg_body~load_coins();
        slice recipient = in_msg_body~load_msg_addr();

        ;; Validate operation amount
        validate_operation_amount(amount);

        ;; Safe balance update
        ton_balance = safe_add(ton_balance, amount);
        save_data(owner, paused, ton_balance, usdt_balance, channel_count,
                  emergency_enabled, reentrancy_guard, time_lock, proposed_owner,
                  owner_change_time, access_control_hash, security_events);

        ;; Log security event
        log_security_event(op::security_event, sender_address, amount, now());

        ;; Send confirmation with gas limit
        validate_gas_limit(50000);
        var msg = begin_cell()
            .store_uint(0x18, 6) ;; bounce bit + message flag
            .store_slice(recipient)
            .store_coins(0) ;; no value
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1) ;; default message header
            .store_uint(0x4e4f54494659, 32) ;; notification op
            .store_coins(amount)
            .end_cell();

        send_raw_message(msg, 64); ;; carry all remaining value

    } elseif (op == op::emergency_pause) {
        ;; Enhanced emergency pause with time lock
        int user_role = check_access(sender_address, role::owner);
        throw_unless(err::unauthorized, user_role == role::owner);

        ;; Check time lock for emergency operations
        check_time_lock(now() - emergency_cooldown);

        paused = 1;
        save_data(owner, paused, ton_balance, usdt_balance, channel_count,
                  emergency_enabled, reentrancy_guard, time_lock, proposed_owner,
                  owner_change_time, access_control_hash, security_events);

        ;; Log security event
        log_security_event(op::security_event, sender_address, 0, now());

    } elseif (op == op::emergency_withdraw) {
        ;; Enhanced emergency withdraw with comprehensive validation
        int user_role = check_access(sender_address, role::owner);
        throw_unless(err::unauthorized, user_role == role::owner);

        ;; Validate message structure
        validate_message_structure(in_msg_body, 64 + 256 + 1);

        int amount = in_msg_body~load_coins();
        slice recipient = in_msg_body~load_msg_addr();
        int is_usdt = in_msg_body~load_uint(1); ;; 0 for TON, 1 for USDT

        ;; Validate operation amount
        validate_operation_amount(amount);

        if (is_usdt) {
            throw_unless(err::insufficient_funds, amount <= usdt_balance);
            usdt_balance = safe_sub(usdt_balance, amount);
        } else {
            throw_unless(err::insufficient_funds, amount <= ton_balance);
            ton_balance = safe_sub(ton_balance, amount);
        }

        save_data(owner, paused, ton_balance, usdt_balance, channel_count,
                  emergency_enabled, reentrancy_guard, time_lock, proposed_owner,
                  owner_change_time, access_control_hash, security_events);

        ;; Log security event
        log_security_event(op::security_event, sender_address, amount, now());

        ;; Send emergency withdrawal with gas limit
        validate_gas_limit(100000);
        var msg = begin_cell()
            .store_uint(0x10, 6) ;; bounce bit
            .store_slice(recipient)
            .store_coins(amount)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_uint(0x454d455247454e43, 32) ;; EMERGENCY
            .end_cell();

        send_raw_message(msg, 3); ;; pay transfer fees separately

    } elseif (op == op::withdraw) {
        ;; Enhanced withdraw with comprehensive security
        int user_role = check_access(sender_address, role::owner);
        throw_unless(err::unauthorized, user_role == role::owner);

        ;; Validate message structure
        validate_message_structure(in_msg_body, 64 + 256 + 8);

        int amount = in_msg_body~load_coins();
        slice recipient = in_msg_body~load_msg_addr();
        int currency = in_msg_body~load_uint(8); ;; 0 for TON, 1 for USDT

        ;; Validate operation amount
        validate_operation_amount(amount);

        if (currency == 1) {
            ;; USDT withdrawal with enhanced security
            throw_unless(err::insufficient_funds, amount <= usdt_balance);
            usdt_balance = safe_sub(usdt_balance, amount);
            save_data(owner, paused, ton_balance, usdt_balance, channel_count,
                      emergency_enabled, reentrancy_guard, time_lock, proposed_owner,
                      owner_change_time, access_control_hash, security_events);

            ;; Log security event
            log_security_event(op::security_event, sender_address, amount, now());

            validate_gas_limit(100000);
            var msg = begin_cell()
                .store_uint(0x18, 6) ;; bounce bit
                .store_slice(recipient)
                .store_coins(0) ;; no TON value
                .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                .store_uint(0x55534454574954, 32) ;; USDTWITHDRAW
                .store_coins(amount)
                .end_cell();

            send_raw_message(msg, 64);

        } else {
            ;; TON withdrawal with enhanced security
            throw_unless(err::insufficient_funds, amount <= ton_balance);
            ton_balance = safe_sub(ton_balance, amount);
            save_data(owner, paused, ton_balance, usdt_balance, channel_count,
                      emergency_enabled, reentrancy_guard, time_lock, proposed_owner,
                      owner_change_time, access_control_hash, security_events);

            ;; Log security event
            log_security_event(op::security_event, sender_address, amount, now());

            validate_gas_limit(100000);
            var msg = begin_cell()
                .store_uint(0x10, 6) ;; external outbound message
                .store_slice(recipient)
                .store_coins(amount)
                .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1) ;; default message header
                .end_cell();

            send_raw_message(msg, 3); ;; pay transfer fees separately
        }

    } elseif (op == op::propose_owner_change) {
        ;; Enhanced ownership change proposal with time lock
        int user_role = check_access(sender_address, role::owner);
        throw_unless(err::unauthorized, user_role == role::owner);

        ;; Validate message structure
        validate_message_structure(in_msg_body, 256);

        slice new_owner = in_msg_body~load_msg_addr();
        int current_time = now();

        ;; Set time lock for ownership change
        int new_time_lock = current_time + time_lock_delay;

        save_data(owner, paused, ton_balance, usdt_balance, channel_count,
                  emergency_enabled, reentrancy_guard, new_time_lock, new_owner,
                  current_time, access_control_hash, security_events);

        ;; Log security event
        log_security_event(op::security_event, sender_address, 0, current_time);

    } elseif (op == op::confirm_owner_change) {
        ;; Confirm ownership change after time lock
        int user_role = check_access(sender_address, role::owner);
        throw_unless(err::unauthorized, user_role == role::owner);

        int current_time = now();
        throw_unless(err::time_lock_active, current_time >= time_lock);
        throw_unless(err::operation_not_allowed, proposed_owner != 0);

        ;; Execute ownership change
        save_data(proposed_owner, paused, ton_balance, usdt_balance, channel_count,
                  emergency_enabled, reentrancy_guard, 0, 0, 0,
                  access_control_hash, security_events);

        ;; Log security event
        log_security_event(op::security_event, sender_address, 0, current_time);

    } elseif (op == op::create_channel) {
        ;; Enhanced channel creation with comprehensive validation
        int user_role = check_access(sender_address, role::owner);
        throw_unless(err::unauthorized, user_role == role::owner);

        ;; Validate message structure
        validate_message_structure(in_msg_body, 256 + 64 + 32);

        slice participant = in_msg_body~load_msg_addr();
        int capacity = in_msg_body~load_coins();
        uint32 duration = in_msg_body~load_uint(32);

        ;; Validate parameters
        validate_operation_amount(capacity);
        throw_unless(err::invalid_amount, duration > 0 & duration <= 365 * 24 * 60 * 60); ;; Max 1 year
        throw_unless(err::insufficient_funds, capacity <= ton_balance);

        ;; Safe balance update
        ton_balance = safe_sub(ton_balance, capacity);
        channel_count = safe_add(channel_count, 1);

        int current_time = now();
        validate_timestamp(current_time);

        save_data(owner, paused, ton_balance, usdt_balance, channel_count,
                  emergency_enabled, reentrancy_guard, time_lock, proposed_owner,
                  owner_change_time, access_control_hash, security_events);

        ;; Store channel data with enhanced security
        cell channel_data = begin_cell()
            .store_slice(participant)
            .store_coins(capacity)
            .store_uint(current_time + duration, 64) ;; expiry with validated timestamp
            .store_coins(0) ;; spent amount
            .store_uint(current_time, 64) ;; creation time
            .end_cell();

        ;; Log security event
        log_security_event(op::security_event, sender_address, capacity, current_time);

        ;; Send channel created notification with gas limit
        validate_gas_limit(75000);
        var msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(participant)
            .store_coins(0)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_uint(0x4348414e4e454c43524541, 32) ;; CHANNEL_CREATED
            .store_ref(channel_data)
            .end_cell();

        send_raw_message(msg, 64);

    } elseif (op == op::channel_payment) {
        ;; Enhanced channel payment with proper validation
        ;; Note: This is a simplified implementation - production should use proper channel state management
        validate_message_structure(in_msg_body, 32 + 64 + 256);

        uint32 channel_id = in_msg_body~load_uint(32);
        int amount = in_msg_body~load_coins();
        slice recipient = in_msg_body~load_msg_addr();

        ;; Validate parameters
        validate_operation_amount(amount);

        ;; TODO: Implement proper channel verification logic
        ;; For now, just process payment with logging

        ;; Log security event
        log_security_event(op::security_event, sender_address, amount, now());

        ;; Send notification with gas limit
        validate_gas_limit(50000);
        var msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(recipient)
            .store_coins(0)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_uint(0x4348414e4e454c5041594d44, 32) ;; CHANNEL_PAID
            .store_uint(channel_id, 32)
            .store_coins(amount)
            .end_cell();

        send_raw_message(msg, 64);

    } else {
        ;; Unknown operation
        throw(err::invalid_operation);
    }

    ;; Clear reentrancy guard after operation completion
    if ((op != op::get_state) & (op != op::security_event)) {
        set_reentrancy_guard(false);
    }
}

;; Enhanced external message with security validation
() recv_external(slice in_msg) impure {
    if (in_msg.slice_empty?()) {
        return ();
    }

    ;; Validate message structure
    validate_message_structure(in_msg, 32);

    int op = in_msg~load_uint(32);

    ;; Only respond to state queries
    if (op != op::get_state) {
        throw(err::invalid_operation);
    }

    if (in_msg.slice_empty?()) {
        return ();
    }

    slice response_addr = in_msg~load_msg_addr();

    (_, (int owner, int paused, int ton_balance, int usdt_balance, int channel_count,
         int emergency_enabled, int reentrancy_guard, int time_lock, int proposed_owner,
         int owner_change_time, int access_control_hash, int security_events)) = load_data();

    ;; Build payload with current contract state (enhanced)
    cell payload = begin_cell()
        .store_uint(op::get_state, 32)
        .store_slice(parse_std_addr(owner))
        .store_uint(paused, 1)
        .store_coins(ton_balance)
        .store_coins(usdt_balance)
        .store_uint(channel_count, 32)
        .store_uint(emergency_enabled, 1)
        .store_uint(reentrancy_guard, 1)
        .store_uint(time_lock, 32)
        .store_slice(parse_std_addr(proposed_owner))
        .store_uint(owner_change_time, 32)
        .store_uint(security_events, 256)
        .end_cell();

    ;; Send response back to requester with gas limit
    validate_gas_limit(100000);
    cell msg = begin_cell()
        .store_uint(0x18, 6) ;; bounceable internal message
        .store_slice(response_addr)
        .store_coins(0)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_ref(payload)
        .end_cell();

    send_raw_message(msg, 3);
}