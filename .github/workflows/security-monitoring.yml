name: 🔔 Security Monitoring & Alerting

on:
  schedule:
    # Run every 30 minutes for continuous monitoring
    - cron: '*/30 * * * *'
  workflow_dispatch:
    inputs:
      check_type:
        description: 'Type of security check'
        required: false
        default: 'all'
        type: choice
        options:
          - all
          - api-health
          - ssl-certificates
          - service-availability
          - security-headers
          - rate-limits
          - authentication

env:
  WEBHOOK_URL: ${{ secrets.SECURITY_WEBHOOK_URL }}
  SLACK_WEBHOOK: ${{ secrets.SLACK_SECURITY_WEBHOOK }}
  SENTRY_DSN: ${{ secrets.SENTRY_DSN }}

jobs:
  # API Health & Security Monitoring
  api-security-check:
    name: 🔍 API Security Check
    runs-on: ubuntu-latest
    if: github.event.inputs.check_type == 'all' || github.event.inputs.check_type == 'api-health' || github.event.schedule

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: '9.15.1'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run API Security Check
        run: |
          # Create security monitoring script
          cat > security-check.js << 'EOF'
          const https = require('https');
          const http = require('http');

          const services = [
            { name: 'Main App', url: process.env.MAIN_APP_URL || 'https://labelmint.it' },
            { name: 'API Gateway', url: process.env.API_GATEWAY_URL || 'https://api.labelmint.it' },
            { name: 'Enterprise API', url: process.env.ENTERPRISE_API_URL || 'https://enterprise-api.labelmint.it' }
          ];

          const checks = {
            sslCertificate: async (url) => {
              return new Promise((resolve) => {
                const client = https.request(url, { method: 'HEAD' }, (res) => {
                  resolve({
                    valid: res.socket.authorized || false,
                    protocol: res.socket.getProtocol(),
                    cert: res.socket.getPeerCertificate ? true : false
                  });
                });
                client.on('error', () => resolve({ valid: false }));
                client.end();
              });
            },

            securityHeaders: async (url) => {
              return new Promise((resolve) => {
                https.get(url, (res) => {
                  const headers = res.headers;
                  const securityHeaders = {
                    'strict-transport-security': headers['strict-transport-security'],
                    'x-frame-options': headers['x-frame-options'],
                    'x-xss-protection': headers['x-xss-protection'],
                    'x-content-type-options': headers['x-content-type-options'],
                    'content-security-policy': headers['content-security-policy'],
                    'referrer-policy': headers['referrer-policy']
                  };

                  const missingHeaders = Object.entries(securityHeaders)
                    .filter(([key, value]) => !value)
                    .map(([key]) => key);

                  resolve({
                    present: Object.keys(securityHeaders).length - missingHeaders.length,
                    missing: missingHeaders
                  });
                });
              });
            },

            responseTime: async (url) => {
              return new Promise((resolve) => {
                const start = Date.now();
                https.get(url, (res) => {
                  resolve({
                    status: res.statusCode,
                    responseTime: Date.now() - start
                  });
                }).on('error', () => resolve({ status: 0, responseTime: -1 }));
              });
            }
          };

          async function runSecurityChecks() {
            console.log('Running security checks...');
            const results = [];

            for (const service of services) {
              console.log(`Checking ${service.name}...`);
              try {
                const [ssl, headers, response] = await Promise.all([
                  checks.sslCertificate(service.url),
                  checks.securityHeaders(service.url),
                  checks.responseTime(service.url)
                ]);

                results.push({
                  service: service.name,
                  url: service.url,
                  ssl: ssl.valid,
                  securityHeaders: headers.present,
                  missingHeaders: headers.missing,
                  responseTime: response.responseTime,
                  status: response.status,
                  healthy: ssl.valid && response.status >= 200 && response.status < 300
                });
              } catch (error) {
                results.push({
                  service: service.name,
                  url: service.url,
                  error: error.message,
                  healthy: false
                });
              }
            }

            return results;
          }

          runSecurityChecks().then(results => {
            console.log('Security check results:', JSON.stringify(results, null, 2));

            // Check for issues
            const issues = results.filter(r => !r.healthy);
            if (issues.length > 0) {
              console.error('Security issues detected:', issues);
              process.exit(1);
            }
          }).catch(error => {
            console.error('Security check failed:', error);
            process.exit(1);
          });
          EOF

          # Run the security check
          node security-check.js

      - name: Send Security Alert
        if: failure()
        run: |
          # Send alert to webhook
          curl -X POST "$WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -d '{
              "alert_type": "security_monitoring",
              "severity": "high",
              "message": "Security issues detected in API endpoints",
              "timestamp": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'",
              "repository": "'$GITHUB_REPOSITORY'",
              "workflow": "'$GITHUB_WORKFLOW'",
              "run_id": "'$GITHUB_RUN_ID'"
            }'

          # Send to Slack if configured
          if [ -n "$SLACK_WEBHOOK" ]; then
            curl -X POST "$SLACK_WEBHOOK" \
              -H 'Content-Type: application/json' \
              -d '{
                "text": "🚨 Security Alert: Issues detected in API endpoints",
                "attachments": [{
                  "color": "danger",
                  "fields": [{
                    "title": "Repository",
                    "value": "'$GITHUB_REPOSITORY'",
                    "short": true
                  }, {
                    "title": "Workflow",
                    "value": "'$GITHUB_WORKFLOW'",
                    "short": true
                  }, {
                    "title": "Run ID",
                    "value": "'$GITHUB_RUN_ID'",
                    "short": true
                  }]
                }]
              }'
          fi

  # Authentication Service Monitoring
  auth-monitoring:
    name: 🔐 Authentication Monitoring
    runs-on: ubuntu-latest
    if: github.event.inputs.check_type == 'all' || github.event.inputs.check_type == 'authentication'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Create Auth Monitoring Script
        run: |
          cat > auth-monitor.js << 'EOF'
          const https = require('https');

          // Monitor authentication endpoints
          const authEndpoints = [
            { name: 'Login', path: '/api/auth/login' },
            { name: 'Register', path: '/api/auth/register' },
            { name: 'SSO', path: '/api/auth/sso' },
            { name: 'Token Refresh', path: '/api/auth/refresh' }
          ];

          async function testAuthEndpoints() {
            const baseUrl = process.env.BASE_URL || 'https://api.labelmint.it';
            const results = [];

            for (const endpoint of authEndpoints) {
              console.log(`Testing ${endpoint.name} endpoint...`);

              try {
                const startTime = Date.now();
                const response = await fetch(\`\${baseUrl}\${endpoint.path}`, {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'User-Agent': 'LabelMint-Security-Monitor/1.0'
                  },
                  body: JSON.stringify({
                    test: 'security_monitoring',
                    timestamp: new Date().toISOString()
                  })
                });

                const responseTime = Date.now() - startTime;

                results.push({
                  endpoint: endpoint.name,
                  path: endpoint.path,
                  status: response.status,
                  responseTime: responseTime,
                  headers: Object.fromEntries(response.headers.entries()),
                  available: response.status >= 200 && response.status < 500
                });
              } catch (error) {
                results.push({
                  endpoint: endpoint.name,
                  path: endpoint.path,
                  error: error.message,
                  available: false
                });
              }
            }

            return results;
          }

          testAuthEndpoints().then(results => {
            console.log(JSON.stringify(results, null, 2));

            // Check for auth service issues
            const unavailable = results.filter(r => !r.available);
            if (unavailable.length > 0) {
              console.error('Authentication service issues detected:', unavailable);
              process.exit(1);
            }
          });
          EOF

          node auth-monitor.js

      - name: Report Auth Issues
        if: failure()
        run: |
          curl -X POST "$WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -d '{
              "alert_type": "authentication_monitoring",
              "severity": "critical",
              "message": "Authentication service issues detected",
              "timestamp": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'"
            }'

  # Rate Limiting Monitor
  rate-limit-monitor:
    name: 🚦 Rate Limit Monitor
    runs-on: ubuntu-latest
    if: github.event.inputs.check_type == 'all' || github.event.inputs.check_type == 'rate-limits'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Create Rate Limit Test Script
        run: |
          cat > rate-limit-test.js << 'EOF'
          const https = require('https');

          // Test rate limiting by making multiple requests
          async function testRateLimiting() {
            const baseUrl = process.env.BASE_URL || 'https://api.labelmint.it';
            const testEndpoint = '/api/health';
            const maxRequests = 100;
            const concurrentRequests = 10;

            const results = [];
            const startTime = Date.now();

            // Make concurrent requests to test rate limiting
            const requests = [];
            for (let i = 0; i < concurrentRequests; i++) {
              requests.push(
                fetch(\`\${baseUrl}\${testEndpoint}`, {
                  method: 'GET',
                  headers: {
                    'X-Test-ID': \`rate-limit-test-\${i}\`,
                    'User-Agent': 'LabelMint-RateLimit-Test/1.0'
                  }
                })
              );
            }

            try {
              const responses = await Promise.allSettled(requests);
              responses.forEach((response, index) => {
                if (response.status === 'fulfilled') {
                  results.push({
                    requestId: index,
                    status: response.value.status,
                    headers: Object.fromEntries(response.value.headers.entries()),
                    rateLimited: response.value.status === 429
                  });
                } else {
                  results.push({
                    requestId: index,
                    error: response.reason.message,
                    failed: true
                  });
                }
              });
            } catch (error) {
              console.error('Rate limit test failed:', error);
            }

            const duration = Date.now() - startTime;
            const rateLimited = results.filter(r => r.rateLimited).length;

            console.log(JSON.stringify({
              duration,
              totalRequests: requests.length,
              rateLimited,
              results
            }, null, 2));

            // Alert if rate limiting not working as expected
            if (rateLimited === 0 && duration < 5000) {
              console.warn('Rate limiting may not be working correctly');
              // Don't fail the job, just warn
            }
          }

          testRateLimiting();
          EOF

          node rate-limit-test.js

  # SSL Certificate Monitor
  ssl-monitor:
    name: 🔒 SSL Certificate Monitor
    runs-on: ubuntu-latest
    if: github.event.inputs.check_type == 'all' || github.event.inputs.check_type == 'ssl-certificates'

    steps:
      - name: SSL Certificate Check
        run: |
          # List of domains to monitor
          domains=(
            "labelmint.it"
            "app.labelmint.it"
            "api.labelmint.it"
            "enterprise-api.labelmint.it"
          )

          issues_found=false

          for domain in "${domains[@]}"; do
            echo "Checking SSL certificate for $domain..."

            # Get certificate expiration info
            cert_info=$(echo | openssl s_client -connect "$domain:443" -servername "$domain" 2>/dev/null | openssl x509 -noout -dates 2>/dev/null)

            if [ $? -eq 0 ]; then
              not_after=$(echo "$cert_info" | grep "notAfter" | cut -d= -f2)
              if [ -n "$not_after" ]; then
                # Convert to epoch time
                expiry_epoch=$(date -d "$not_after" +%s 2>/dev/null || echo 0)
                current_epoch=$(date +%s)
                days_until_expiry=$(( (expiry_epoch - current_epoch) / 86400 ))

                echo "Domain: $domain, Days until expiry: $days_until_expiry"

                if [ $days_until_expiry -lt 30 ]; then
                  echo "🚨 SSL certificate for $domain expires in $days_until_expiry days!"
                  issues_found=true
                fi
              fi
            else
              echo "❌ Failed to get SSL certificate for $domain"
              issues_found=true
            fi
          done

          if [ "$issues_found" = true ]; then
            exit 1
          fi

      - name: Send SSL Alert
        if: failure()
        run: |
          curl -X POST "$WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -d '{
              "alert_type": "ssl_certificate_monitoring",
              "severity": "high",
              "message": "SSL certificate issues detected",
              "timestamp": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'"
            }'

  # Security Headers Monitor
  security-headers-monitor:
    name: 🛡️ Security Headers Monitor
    runs-on: ubuntu-latest
    if: github.event.inputs.check_type == 'all' || github.event.inputs.check_type == 'security-headers'

    steps:
      - name: Security Headers Check
        run: |
          # Critical security headers to check
          critical_headers=(
            "strict-transport-security"
            "x-frame-options"
            "x-xss-protection"
            "x-content-type-options"
            "content-security-policy"
            "referrer-policy"
          )

          endpoints=(
            "https://labelmint.it"
            "https://api.labelmint.it"
            "https://app.labelmint.it"
          )

          issues_found=false

          for endpoint in "${endpoints[@]}"; do
            echo "Checking security headers for $endpoint..."

            # Get headers
            headers=$(curl -s -I "$endpoint" | tr -d '\r')

            missing_headers=()

            for header in "${critical_headers[@]}"; do
              if ! echo "$headers" | grep -qi "^${header//_/-}:"; then
                missing_headers+=("$header")
                issues_found=true
              fi
            done

            if [ ${#missing_headers[@]} -gt 0 ]; then
              echo "❌ Missing security headers for $endpoint: ${missing_headers[*]}"
            else
              echo "✅ All critical security headers present for $endpoint"
            fi
          done

          if [ "$issues_found" = true ]; then
            exit 1
          fi

      - name: Send Security Headers Alert
        if: failure()
        run: |
          curl -X POST "$WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -d '{
              "alert_type": "security_headers_monitoring",
              "severity": "medium",
              "message": "Missing security headers detected",
              "timestamp": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'"
            }'

  # Generate Monitoring Report
  monitoring-report:
    name: 📊 Generate Monitoring Report
    runs-on: ubuntu-latest
    needs: [api-security-check, ssl-monitor, security-headers-monitor, auth-monitoring, rate-limit-monitor]
    if: always()

    steps:
      - name: Generate Report
        run: |
          cat > monitoring-report.md << 'EOF'
          # 📊 Security Monitoring Report

          **Generated**: $(date -u +%Y-%m-%dT%H:%M:%SZ)
          **Repository**: $GITHUB_REPOSITORY
          **Workflow**: $GITHUB_WORKFLOW
          **Run ID**: $GITHUB_RUN_ID

          ## Job Status Summary

          | Job | Status | Result |
          |-----|--------|--------|
          EOF

          # Add job results
          for job in "api-security-check" "ssl-monitor" "security-headers-monitor" "auth-monitoring" "rate-limit-monitor"; do
            status="${{ needs.$job.result || 'skipped' }}"
            result=""

            case "$status" in
              "success") result="✅ Passed" ;;
              "failure") result="❌ Failed" ;;
              "skipped") result="⏭ Skipped" ;;
              *) result="❓ Unknown" ;;
            esac

            echo "| $job | $status | $result |" >> monitoring-report.md
          done

          echo "" >> monitoring-report.md
          echo "## 📅 Next Steps" >> monitoring-report.md
          echo "1. Review any failed jobs" >> monitoring-report.md
          echo "2. Investigate security issues" >> monitoring-report.md
          echo "3. Update monitoring configuration if needed" >> monitoring-report.md
          echo "4. Schedule follow-up checks" >> monitoring-report.md
          EOF

      - name: Upload Monitoring Report
        uses: actions/upload-artifact@v4
        with:
          name: security-monitoring-report
          path: monitoring-report.md
          retention-days: 30

      - name: Send Report to Webhook
        if: always()
        run: |
          curl -X POST "$WEBHOOK_URL" \
            -H "Content-Type: application/json" \
            -d '{
              "alert_type": "monitoring_report",
              "severity": "info",
              "message": "Security monitoring report completed",
              "timestamp": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'",
              "workflow": "'$GITHUB_WORKFLOW'",
              "run_id": "'$GITHUB_RUN_ID'"
            }'