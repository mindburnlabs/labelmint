# ============================================================================
# POSTGRESQL PRODUCTION CONFIGURATION FOR LABELMINT
# Optimized for high-concurrency microservices architecture
# ============================================================================

# ============================================================================
# CONNECTION SETTINGS
# ============================================================================

# Connection limits (adjust based on server RAM and concurrent users)
max_connections = 400                    # Total connections
superuser_reserved_connections = 5       # Reserved for superusers

# Connection validation
tcp_keepalives_idle = 600                # 10 minutes
tcp_keepalives_interval = 30             # 30 seconds
tcp_keepalives_count = 3                 # 3 tries before timeout

# ============================================================================
# MEMORY CONFIGURATION (32GB RAM Server)
# ============================================================================

# Shared memory
shared_buffers = 8GB                     # 25% of RAM
huge_pages = try                         # Use huge pages if available

# Work memory for operations
work_mem = 256MB                         # Per operation memory
maintenance_work_mem = 2GB               # For maintenance operations
autovacuum_work_mem = -1                 # Use maintenance_work_mem

# Query optimization
effective_cache_size = 24GB              # 75% of RAM
default_statistics_target = 100          # Better statistics for query planner

# ============================================================================
# WAL (WRITE-AHEAD LOGGING) CONFIGURATION
# ============================================================================

# WAL settings for durability and performance
wal_level = replica                      # Support replication
max_wal_size = 4GB                       # Maximum WAL size
min_wal_size = 1GB                       # Minimum WAL size
wal_buffers = 64MB                       # WAL buffer size
wal_writer_delay = 200ms                 # WAL flush delay

# Checkpoint configuration
checkpoint_completion_target = 0.9       # Spread checkpoint I/O over time
checkpoint_timeout = 15min               # Maximum time between checkpoints
checkpoint_warning = 30s                 # Warning if checkpoint takes longer

# WAL archiving for backup and replication
archive_mode = on
archive_command = 'cp %p /var/lib/postgresql/wal_archive/%f'
archive_timeout = 60min                  # Force WAL switch every hour

# ============================================================================
# REPLICATION CONFIGURATION
# ============================================================================

# Streaming replication
max_wal_senders = 6                      # Number of replication connections
max_replication_slots = 6                 # Number of replication slots
wal_keep_size = 2GB                      # Keep WAL for replica recovery
hot_standby = on                         # Allow read queries on replicas

# Synchronous replication (adjust based on consistency requirements)
synchronous_commit = remote_apply        # Strong consistency for critical data
synchronous_standby_names = 'replica1,replica2'  # Synchronous replicas

# ============================================================================
# QUERY PLANNER AND EXECUTION
# ============================================================================

# Query planning
enable_seqscan = on                      # Allow sequential scans
enable_indexscan = on                    # Enable index scans
enable_bitmapscan = on                   # Enable bitmap scans
enable_hashjoin = on                     # Enable hash joins
enable_mergejoin = on                    # Enable merge joins
enable_nestloop = on                     # Enable nested loops

# Parallel query settings
max_parallel_workers_per_gather = 4      # Parallel workers per query
max_parallel_workers = 8                 # Total parallel workers
max_parallel_maintenance_workers = 4     # For maintenance operations

# Join optimization
from_collapse_limit = 8                  # Collapse FROM lists
join_collapse_limit = 8                  # Collapse join lists

# ============================================================================
# AUTOVACUUM CONFIGURATION
# ============================================================================

# Autovacuum daemon settings
autovacuum = on
autovacuum_max_workers = 4               # Number of autovacuum workers
autovacuum_naptime = 30s                 # Time between vacuum runs

# Vacuum thresholds
autovacuum_vacuum_threshold = 50         # Rows needed to trigger vacuum
autovacuum_vacuum_scale_factor = 0.1     # Percentage of table to trigger vacuum
autovacuum_analyze_threshold = 50        # Rows needed to trigger analyze
autovacuum_analyze_scale_factor = 0.05   # Percentage of table to trigger analyze

# Aggressive vacuum for high-traffic tables
autovacuum_vacuum_cost_delay = 5ms       # Reduce delay for faster vacuum
autovacuum_vacuum_cost_limit = -1        # Unlimited cost budget per run

# Table-specific autovacuum settings (to be applied via ALTER TABLE)
# These are examples - adjust based on actual table usage patterns
# ALTER TABLE tasks SET (autovacuum_vacuum_scale_factor = 0.05, autovacuum_analyze_scale_factor = 0.02);

# ============================================================================
# LOGGING CONFIGURATION
# ============================================================================

# General logging
logging_collector = on
log_destination = 'stderr,csvlog'
log_directory = 'log'
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log'
log_rotation_age = 1d
log_rotation_size = 100MB
log_truncate_on_rotation = off

# Log levels
log_min_messages = warning                # Minimum message level to log
log_min_error_statement = error          # Log failed statements
log_min_duration_statement = 1000        # Log slow queries (>1s)

# Detailed logging
log_checkpoints = on                     # Log checkpoints
log_connections = on                     # Log connections
log_disconnections = on                  # Log disconnections
log_lock_waits = on                      # Log lock waits
log_temp_files = 10MB                    # Log temporary files >10MB
log_autovacuum_min_duration = 0          # Log all autovacuum activity

# Query logging for monitoring
log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '
log_statement = 'none'                   # Don't log all queries (use pg_stat_statements)
log_timezone = 'UTC'

# ============================================================================
# CLIENT CONNECTION DEFAULTS
# ============================================================================

# Statement timeouts
statement_timeout = 30000                # 30 seconds per statement
lock_timeout = 10000                     # 10 seconds for lock acquisition
idle_in_transaction_session_timeout = 60000  # 1 minute idle transaction timeout

# Session settings
timezone = 'UTC'
default_text_search_config = 'pg_catalog.english'
default_transaction_isolation = 'read committed'
default_transaction_deferrable = off

# Client authentication
client_min_messages = notice             # Minimum message level to send to client
search_path = '"$user", public'          # Default search path

# ============================================================================
# EXTENSIONS AND MODULES
# ============================================================================

# Load performance monitoring extensions
shared_preload_libraries = 'pg_stat_statements,auto_explain,pg_stat_statements_info'

# pg_stat_statements configuration
track_activity_query_size = 2048         # Track longer queries
pg_stat_statements.max = 10000           # Maximum number of statements to track
pg_stat_statements.track = all           # Track all statements
pg_stat_statements.track_utility = off  # Don't track utility commands
pg_stat_statements.save = on             # Save statistics across restarts

# auto_explain configuration
auto_explain.log_min_duration = 1000     # Explain queries >1s
auto_explain.log_analyze = on            # Include actual execution stats
auto_explain.log_buffers = on            # Include buffer usage
auto_explain.log_timing = on             # Include timing
auto_explain.log_triggers = on           # Include trigger stats
auto_explain.log_verbose = on            # Include verbose output
auto_explain.log_format = json           # JSON format for easier parsing
auto_explain.sample_rate = 0.1           # Sample 10% of queries

# ============================================================================
# RESOURCE MANAGEMENT
# ============================================================================

# Memory limits
temp_file_limit = 10GB                   # Limit temporary file space
vacuum_cost_delay = 5ms                  # Vacuum throttle delay
vacuum_cost_page_hit = 1                 # Vacuum cost for buffer hit
vacuum_cost_page_miss = 10               # Vacuum cost for buffer miss
vacuum_cost_page_dirty = 20              # Vacuum cost for dirty page
vacuum_cost_limit = 200                  # Vacuum cost limit per cycle

# Background writer
bgwriter_delay = 200ms                   # Background writer delay
bgwriter_lru_maxpages = 100              # Max pages to flush per round
bgwriter_lru_multiplier = 2.0            # Multiplier for buffer eviction
bgwriter_flush_after = 512kB             # Flush after this amount

# ============================================================================
# SECURITY CONFIGURATION
# ============================================================================

# SSL/TLS (uncomment and configure for production)
# ssl = on
# ssl_cert_file = '/etc/ssl/certs/server.crt'
# ssl_key_file = '/etc/ssl/private/server.key'
# ssl_ca_file = '/etc/ssl/certs/ca.crt'
# ssl_crl_file = '/etc/ssl/certs/server.crl'

# Authentication security
password_encryption = scram-sha-256       # Strong password hashing

# ============================================================================
# MONITORING AND STATISTICS
# ============================================================================

# Statistics collection
track_counts = on                        # Track row counts
track_io_timing = on                     # Track I/O timing
track_functions = none                   # Don't track function usage

# Performance monitoring
cpu_operator_cost = 0.0025               # CPU operator cost
cpu_tuple_cost = 0.01                    # Tuple processing cost
cpu_index_tuple_cost = 0.005             # Index tuple cost
seq_page_cost = 1.0                      # Sequential page cost
random_page_cost = 1.1                   # Random page cost (for SSD)

# ============================================================================
# PARTITIONING CONFIGURATION
# ============================================================================

# Partitioning settings
enable_partition_pruning = on            # Enable partition pruning
enable_partitionwise_join = on           # Enable partitionwise joins
enable_partitionwise_aggregate = on      # Enable partitionwise aggregates

# ============================================================================
# OPTIMIZER HINTS AND TUNING
# ============================================================================

# Genetic query optimizer
geqo = on                                # Enable genetic query optimizer
geqo_threshold = 12                      # Use genetic optimizer for >12 tables
geqo_effort = 5                          # Genetic optimizer effort
geqo_pool_size = 0                       # Genetic optimizer pool size (0 = auto)
geqo_generations = 0                     # Genetic optimizer generations (0 = auto)
geqo_selection_bias = 2.0                # Genetic optimizer selection bias

# Join order optimization
from_collapse_limit = 8                  # Collapse sub-SELECTs into FROM lists
join_collapse_limit = 8                  # Collapse join lists

# JIT compilation (for complex queries)
jit = on                                 # Enable JIT compilation
jit_inline_above_cost = 500000           # Inline functions above this cost
jit_optimize_above_cost = 500000         # Optimize functions above this cost
jit_explain_above_cost = 500000          # Explain functions above this cost

# ============================================================================
# CUSTOM LABELMINT SETTINGS
# ============================================================================

# Custom parameters for application-specific tuning
# These can be referenced in application code

# Task distribution optimization
labelmint.task_batch_size = 100          # Batch size for task distribution
labelmint.max_concurrent_assignments = 1000  # Max concurrent task assignments

# Payment processing optimization
labelmint.payment_batch_size = 50        # Batch size for payment processing
labelmint.payment_timeout = 30000        # Payment processing timeout (ms)

# Analytics optimization
labelmint.analytics_retention_days = 90  # Days to keep analytics data
labelmint.max_concurrent_analytics = 10  # Max concurrent analytics queries

# Cache settings (application-level)
labelmint.cache_ttl = 300                # Cache TTL in seconds
labelmint.cache_max_size = 10000         # Maximum cache entries

# ============================================================================
# ENVIRONMENT-SPECIFIC SETTINGS
# ============================================================================

# Development environment overrides
# These should be applied in development postgresql.conf

# Production environment (high performance)
# shared_buffers = 12GB                   # Higher for production
# effective_cache_size = 28GB             # Higher for production
# work_mem = 512MB                        # Higher for production
# maintenance_work_mem = 4GB              # Higher for production

# Staging environment (balanced)
# shared_buffers = 6GB                    # Balanced for staging
# effective_cache_size = 18GB             # Balanced for staging
# work_mem = 128MB                        # Balanced for staging

# ============================================================================
# MONITORING VIEWS AND FUNCTIONS
# ============================================================================

# Performance monitoring views will be created by separate scripts
# See: /database/monitoring/performance-views.sql

# Health check function
CREATE OR REPLACE FUNCTION system_health_check()
RETURNS TABLE(
    metric_name text,
    value numeric,
    status text,
    threshold numeric
) AS $$
BEGIN
    RETURN QUERY
    -- Connection usage
    SELECT
        'active_connections'::text,
        count(*)::numeric,
        CASE WHEN count(*) > max_connections * 0.8 THEN 'WARNING' ELSE 'OK' END,
        max_connections * 0.8
    FROM pg_stat_activity
    WHERE state = 'active'

    UNION ALL

    -- Cache hit ratio
    SELECT
        'cache_hit_ratio'::text,
        round((sum(blks_hit)::numeric / nullif(sum(blks_hit) + sum(blks_read), 0)) * 100, 2),
        CASE WHEN (sum(blks_hit)::numeric / nullif(sum(blks_hit) + sum(blks_read), 0)) < 0.95 THEN 'WARNING' ELSE 'OK' END,
        95.0
    FROM pg_stat_database
    WHERE datname = current_database()

    UNION ALL

    -- Transaction rate
    SELECT
        'transactions_per_second'::text,
        (sum(xact_commit) + sum(xact_rollback))::numeric / extract(epoch from now() - pg_stat_get_db_stat_reset_time(oid)),
        'OK',
        1000.0
    FROM pg_stat_database
    WHERE datname = current_database();
END;
$$ LANGUAGE plpgsql;

-- Create health check view
CREATE OR REPLACE VIEW system_health AS
SELECT * FROM system_health_check();

-- ============================================================================
# CONFIGURATION VALIDATION
# ============================================================================

-- Function to validate configuration
CREATE OR REPLACE FUNCTION validate_configuration()
RETURNS TABLE(
    setting_name text,
    current_value text,
    recommended_value text,
    status text
) AS $$
BEGIN
    RETURN QUERY
    -- Validate shared_buffers
    SELECT
        'shared_buffers'::text,
        current_setting('shared_buffers'),
        '8GB',
        CASE WHEN (split_part(current_setting('shared_buffers'), ' ', 1))::integer >= 8192 THEN 'OK' ELSE 'REVIEW' END

    UNION ALL

    -- Validate work_mem
    SELECT
        'work_mem'::text,
        current_setting('work_mem'),
        '256MB',
        CASE WHEN (split_part(current_setting('work_mem'), ' ', 1))::integer >= 256 THEN 'OK' ELSE 'REVIEW' END

    UNION ALL

    -- Validate effective_cache_size
    SELECT
        'effective_cache_size'::text,
        current_setting('effective_cache_size'),
        '24GB',
        CASE WHEN (split_part(current_setting('effective_cache_size'), ' ', 1))::integer >= 24576 THEN 'OK' ELSE 'REVIEW' END;
END;
$$ LANGUAGE plpgsql;

-- Create configuration validation view
CREATE OR REPLACE VIEW configuration_validation AS
SELECT * FROM validate_configuration();

-- ============================================================================
# POSTGRESQL CONFIGURATION COMPLETION NOTICE
# ============================================================================

-- This configuration should be placed in postgresql.conf
-- After applying changes, restart PostgreSQL and run:
-- SELECT pg_reload_conf();
-- SELECT * FROM system_health;
-- SELECT * FROM configuration_validation;